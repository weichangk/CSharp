## 继承
<p>
代码中的继承用于定义两个类的“属于”关系，派生类是对基类的特化。
</p>

### 派生
<p>
经常需要扩展现有类型来添加功能(行为和数据)，继承正是为了该目的而设计的。每个派生类都拥有由其所有基类公开的所有成员。
</p>

<p>
派生类型能隐式转型为它的基类，基类向派生类的转换要求显式的转型操作符，因为转换可能失败，虽然编译器允许可能有效的显式转型，但运行时会坚持检查，无效转型将引发异常。基类的受保护成员只能从基类及其派生链的其他类中访问。对一个类型进行扩展的方法也可扩展它的任何派生类型，所有扩展方法在派生类中也能使用。但和所有扩展方法一样，实例方法有更高的优先级，如果继承链中出现一个兼容的签名，那么它将优先于扩展方法。很少为基类写扩展方法，扩展方法的一个基本原则是，如果手上有基类的代码直接修改基类会更好，即使基类代码不可用，也应考虑在基类或个别派生类实现的接口上添加扩展方法。c#是单继承的，有时可以使用聚合的形式包含多个类来解决单继承的缺陷。将类标记为sealed（密封类）来避免非预期的派生。
</p>

### 重写
<p>
C#支持重写实例方法和属性，但不支持字段和任何静态成员的重写。为进行重写，要求在基类和派生类中都显式执行一个操作，基类必须将允许重写的每个成员都标记为virtual。与Java和C++不同, C#应用于派生类的override关键字是必需的。C#不允许隐式重写，为重写方法，基类和派生类成员必须匹配而且要有对应的virtual和override关键字。此外override关键字意味着派生类的实现会替换基类的实现。重写成员会造成“运行时”调用最深的或者说派生得最远的实现。创建类时必须谨慎选择是否允许重写方法，因为控制不了派生的实现，虚方法不应包含关键代码，因为如果派生类重写了它，那些父类引用指向子类对象时，父类引用调用的虚方法代码永远得不到调用，而是调用了子类的重载实现。
</p>

### new 修饰符 和 base 成员

### 抽象类


###