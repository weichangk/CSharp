## 继承
<p>
代码中的继承用于定义两个类的“属于”关系，派生类是对基类的特化。
</p>

### 派生
<p>
经常需要扩展现有类型来添加功能(行为和数据)，继承正是为了该目的而设计的。每个派生类都拥有由其所有基类公开的所有成员。
</p>

<p>
派生类型能隐式转型为它的基类，基类向派生类的转换要求显式的转型操作符，因为转换可能失败，虽然编译器允许可能有效的显式转型，但运行时会坚持检查，无效转型将引发异常。基类的受保护成员只能从基类及其派生链的其他类中访问。对一个类型进行扩展的方法也可扩展它的任何派生类型，所有扩展方法在派生类中也能使用。但和所有扩展方法一样，实例方法有更高的优先级，如果继承链中出现一个兼容的签名，那么它将优先于扩展方法。很少为基类写扩展方法，扩展方法的一个基本原则是，如果手上有基类的代码直接修改基类会更好，即使基类代码不可用，也应考虑在基类或个别派生类实现的接口上添加扩展方法。c#是单继承的，有时可以使用聚合的形式包含多个类来解决单继承的缺陷。将类标记为sealed（密封类）来避免非预期的派生。
</p>

### 重写
<p>
C#支持重写实例方法和属性，但不支持字段和任何静态成员的重写。为进行重写，要求在基类和派生类中都显式执行一个操作，基类必须将允许重写的每个成员都标记为virtual。与Java和C++不同, C#应用于派生类的override关键字是必需的。C#不允许隐式重写，为重写方法，基类和派生类成员必须匹配而且要有对应的virtual和override关键字。此外override关键字意味着派生类的实现会替换基类的实现。重写成员会造成“运行时”调用最深的或者说派生得最远的实现。创建类时必须谨慎选择是否允许重写方法，因为控制不了派生的实现，虚方法不应包含关键代码，因为如果派生类重写了它，那些父类引用指向子类对象时，父类引用调用的虚方法代码永远得不到调用，而是调用了子类的重载实现。
</p>

### 派生红的new修饰符，base成员，构造函数
<p>
如果重写方法没有使用override关键字，编译器会生成警告：warning cs0114: “派生类中的方法名”隐藏继承的成员“基类中的方法名”。若要使当前成员重写该实现，请添加关键字override，否则添加关键字new。使用new修饰符实现在基类面前隐藏了派生类重新声明的成员，这时不是调用派生得最远的成员，是搜索继承链，找到使用new修饰符的那个成员之前的派生得最远的成员，然后调用该成员。如继承链仅包含两个类，就使用基类的成员，就像是派生类没有声明那个成员(如派生的实现重写了基类成员)。假如既没有指定override，也没有指定new，就默认为new。
</p>
<p>
调用基类的实现需使用base关键字，base的语法和this几乎完全一样，也允许作为构造函数的一部分使用。
</p>
<p>
实例化派生类时, “运行时”首先调用基类构造函数，防止绕过基类的初始化机制。但假如基类没有可访问的(非私有)默认构造函数，就不知道如何构造基类, C#编译器将会报错。为避免因为缺少可访问的默认构造函数而造成错误，需要在派生类构造函数的头部显式指定要运行哪一个基类构造函数，如代码public Contact(string name) : base(name){}
</p>

### 抽象类
<p>
抽象类代表抽象实体，其抽象成员定义了从抽象实体派生的对象应包含什么，但这种成员不包含实现。一个类要从抽象类成功地派生，必须为抽象基类中的抽象方法提供具体的实现。抽象类和具体类的不同点是抽象类可以有构造函数但是不能实例化，抽象类可以包含抽象成员。抽象成员是没有实现的方法、属性、索引器、事件，作用是强制所有派生类提供实现。
</p>

- 抽象类和抽象成员必须标记为abstract，并且抽象成员不能有任何实现。
- 抽象成员必须在抽象类中。
- 子类继承抽象类后，必须把父类中的所有抽象成员都重写。（除非子类也是一个抽象类，则可以不重写）
- 抽象成员的访问修饰符不能是private，在抽象类中可以包含实例成员，并且抽象类的实例成员可以不被子类实现。
- 抽象类不能被实例化，但可以有有构造函数，如果声明了有参构造函数，派生类要使用构造函数初始化器将参数传给它。
- 抽象类中的抽象事件。对外公开的事件可以在类的内外部订阅，但只能在类内部触发调用。而抽象类中的抽象事件在抽象类内不能触发调用（由派生类重载后在派生类内部触发调用），可以抽象类中订阅，且订阅的方法在派生类触发事件时会调用得到。
- 抽象类中不能声明抽象委托。
- 抽象类与普通类的主要区别：不能直接使用抽象类来实例化，派生抽象类必须实现抽象成员。

### 使用is操作符验证基础类型
<p>
如：if(dog is Animal){}
</p>

### 使用is操作符进行模式匹配
<p>
使用is操作符验证基础类型并将其转换为其基础类型。如if(dog is Animal animal){animal.xxx;}
</p>

### 使用switch操作符进行模式匹配
<p>
除了可以使用is操作符进行模式匹配之外，还可以使用switch操作符进行模式匹配。通过switch基类引用，可以接收派生类型参数，使用case来判断为具体的派生类并在其后声明类型变量接收派生类型参数变量，再通过when来调用变量，也可以不使用when直接调用变量。
</p>


### 使用as操作符进行转换
<p>
is操作符的优点是允许验证一个数据项是否属于特定类型。as操作符则更进一步，它会将对象转换为特定数据类型，但和转型不同的是如对象不能转换, as操作符会返回null。如：Animal animal = dog as Animal; 使用as操作符可避免用额外的try-catch代码处理转换无效的情况，因为as操作符提供了尝试执行转型但转型失败后不引发异常的一种方式。as操作符一般要求采取额外的步骤对被赋值的变量执行空检查。由于模式匹配is操作符自动包含该检查，所以几乎再也用不着as操作符了。
</p>