## 继承
<p>
代码中的继承用于定义两个类的“属于”关系，派生类是对基类的特化。
</p>

### 派生
<p>
经常需要扩展现有类型来添加功能(行为和数据)，继承正是为了该目的而设计的。每个派生类都拥有由其所有基类公开的所有成员。
</p>

<p>
派生类型能隐式转型为它的基类，基类向派生类的转换要求显式的转型操作符，因为转换可能失败，虽然编译器允许可能有效的显式转型，但运行时会坚持检查，无效转型将引发异常。基类的受保护成员只能从基类及其派生链的其他类中访问。对一个类型进行扩展的方法也可扩展它的任何派生类型，所有扩展方法在派生类中也能使用。但和所有扩展方法一样，实例方法有更高的优先级，如果继承链中出现一个兼容的签名，那么它将优先于扩展方法。很少为基类写扩展方法，扩展方法的一个基本原则是，如果手上有基类的代码直接修改基类会更好，即使基类代码不可用，也应考虑在基类或个别派生类实现的接口上添加扩展方法。c#是单继承的，有时可以使用聚合的形式包含多个类来解决单继承的缺陷。将类标记为sealed（密封类）来避免非预期的派生。
</p>

### 重写
<p>
C#支持重写实例方法和属性，但不支持字段和任何静态成员的重写。为进行重写，要求在基类和派生类中都显式执行一个操作，基类必须将允许重写的每个成员都标记为virtual。与Java和C++不同, C#应用于派生类的override关键字是必需的。C#不允许隐式重写，为重写方法，基类和派生类成员必须匹配而且要有对应的virtual和override关键字。此外override关键字意味着派生类的实现会替换基类的实现。重写成员会造成“运行时”调用最深的或者说派生得最远的实现。创建类时必须谨慎选择是否允许重写方法，因为控制不了派生的实现，虚方法不应包含关键代码，因为如果派生类重写了它，那些父类引用指向子类对象时，父类引用调用的虚方法代码永远得不到调用，而是调用了子类的重载实现。
</p>

### 派生红的new修饰符，base成员，构造函数
<p>
如果重写方法没有使用override关键字，编译器会生成警告：warning cs0114: “派生类中的方法名”隐藏继承的成员“基类中的方法名”。若要使当前成员重写该实现，请添加关键字override，否则添加关键字new。使用new修饰符实现在基类面前隐藏了派生类重新声明的成员，这时不是调用派生得最远的成员，是搜索继承链，找到使用new修饰符的那个成员之前的派生得最远的成员，然后调用该成员。如继承链仅包含两个类，就使用基类的成员，就像是派生类没有声明那个成员(如派生的实现重写了基类成员)。假如既没有指定override，也没有指定new，就默认为new。
</p>
<p>
调用基类的实现需使用base关键字，base的语法和this几乎完全一样，也允许作为构造函数的一部分使用。
</p>
<p>
实例化派生类时, “运行时”首先调用基类构造函数，防止绕过基类的初始化机制。但假如基类没有可访问的(非私有)默认构造函数，就不知道如何构造基类, C#编译器将会报错。为避免因为缺少可访问的默认构造函数而造成错误，需要在派生类构造函数的头部显式指定要运行哪一个基类构造函数，如代码public Contact(string name) : base(name){}
</p>

### 抽象类
<p>
抽象类代表抽象实体，其抽象成员定义了从抽象实体派生的对象应包含什么，但这种成员不包含实现。一个类要从抽象类成功地派生，必须为抽象基类中的抽象方法提供具体的实现。抽象类和具体类的不同点是抽象类可以有构造函数但是不能实例化，抽象类可以包含抽象成员。抽象成员是没有实现的方法或属性，作用是强制所有派生类提供实现。
</p>

