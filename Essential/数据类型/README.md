## 数据类型

<p>
C#有几种类型非常简单，是其他所有类型的基础，它们称为预定义类型(predefined type)或基元类型(primitive type)。编译器直接支持的数据类型称为基元类型。基元类型直接映射到Framework类库(FCL)中存在的类型。使用基元类型对数据大小的体现更直观。
</p>

#### 类型划分
<p>
一个类型要么是值类型，要么是引用类型。区别在于拷贝方式，值类型的数据总是拷贝值，而引用类型的数据总是拷贝引用。
</p>

#### 基本数据类型  
1. 整数类型
    |C#基元类型|大小|范围|FCL名称(Framework类库)|是否有符号|后缀|    
    |:----:|:----:|:----:|:----:|:----:|:----:|
    |sbyte|8位|-(2的n-1次方) ~ 2的n-1次方-1|System.SByte|是||
    |byte|8位|0 ~ 2的n次方-1|System.Byte|否||
    |short|16位||System.Int16|是||
    |ushort|16位||System.UInt16|否||
    |int|32位||System.Int32|是|U或u|
    |uint|32位||System.UInt32|否||
    |long|64位||System.Int64|是|L或l|
    |ulong|64位||System.UInt64|否|UL或ul|


2. 浮点类型
    |C#基元类型|大小|范围|FCL名称(Framework类库)|有效位数|后缀|    
    |:----:|:----:|:----:|:----:|:----:|:----:|
    |float|32位|± 1.5 * 10 ^ -45 ~ 3.4 * 10 ^ 38|System.Single|7|F或f|
    |double|64位|± 5.0 * 10 ^ -324 ~ 1.7 * 10 ^ 308|System.Double|15 ~ 16|D或d|

    <p>
    浮点数的精度可变，在一个表达式中只有当除数是2的整数次幂时才能准确无误的计算出结果，其他情况下用浮点类型无法准确的计算出结果。当我们将浮点类型的变量值设置为0.1时，C#就会很容易表示成0.099999999999999999，或者0.1000000000000000001，或者是一个非常接近0.1的数字。根据定义，浮点数的精度与它所代表的数字的大小成正比，也就是说浮点数的精度是由有效位数的个数决定的，而不是由一个固定值决定的。所以说如果在开发中需要精确的数字（例如金融行业的应用），那么我们就不能使用浮点类型，应该使用 decimal 类型。
    </p>


3. decimal类型
    |C#基元类型|大小|范围|FCL名称(Framework类库)|有效位数|后缀|    
    |:----:|:----:|:----:|:----:|:----:|:----:|
    |decimal|128位|(-7.9 * 10 ^ 28 ~ 7.9 * 10 ^ 28) / (10 ^ 0 ~ 10 ^ 28)|System.Decimal|7|M或m|

    <p>
    虽然decimal类型具有比浮点类型更高的精度，但它的范围较小。所以从浮点类型转换为decimal类型可能发生溢出错误。此外，decimal的计算速度稍慢。
    </p>

4. 布尔类型(bool) System.Boolean true/false值  

5. 字符类型(char) System.Char 16位Unicode
    <p>
    16位不足以表示所有的Unicode字符。一些Unicode字符要由一对称为“代理项”的char构成，总共32位。输入char字面值需要将字符放到一对单引号中。有的字符不能直接插入源代码，需进行特殊处理。反斜杠和特殊字符代码统称为转义序列
    </p>

6. 字符串(string) System.String 字符数组，
    - 字面量
        <p>
        C#允许在字符串前使用@符号，指明转义序列不被处理。结果是一个逐字字符串字面值。
        </p>
    - 字符串插值
        <p>
        从C#6.0起，字符串可用插值技术嵌人表达式。语法是在字符串前添加$符号，并在字符串中用一对大括号嵌入表达式。如：$"Your full name is {firstName} {lastName}." 字符串插值是调用string.Format()方法的语法糖。
        </p>   
    - 不可变
        <p>
        字符串一旦创建就不可修改大小，每次使用System.String类中的方法之一时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。在需要对字符串执行重复修改的情况下，与创建新的String对象相关的系统开销可能会非常昂贵。如果要修改字符串而不创建新的对象，则可以使用System.Text.StringBuilder类。String声明之后在内存中大小是不可修改的，而StringBuilder可以自由扩展大小。
        </p>
#### 更多类型  
1. object

2. 数组

3. 隐式类型
    <p>
    使用var关键字，编译器可以根据变量的初始化值“推断”变量的类型。
    避免使用隐式类型的局部变量,除非所赋的值的数据类型显而易见。
    约束：被声明的变量是一个局部变量，而不是静态字段和实例字段；变量在声明的同时被初始化；初始化表达式不是null；初始化表达式不是方法组，也不是匿名函数;不能把初始化器设置为一个对象，除非在初始化器中创建了一个对象；声明了变量推断出类型后就不能改变变量类型了
    </p>
4. 匿名类型
    <p>
    var与new关键字一起使用时，可以创建匿名类型。匿名类型只是一个继承自Object且没有名称的类。该类的定义从初始化器中推断，类似于隐式类型化的变量。如 var o = new {firstName = "", lastName = ""}; 
    C#3.0添加var的真正目的是支持匿名类型，匿名类型是在方法内部动态声明的数据类型，而不是通过显式的类定义来声明。匿名类型限制属性为只读。
    </p>
5. 可空类型
    <p>
    不能将null值赋给值类型，这是因为根据定义值类型不能包含引用。为声明能存储null的变量，要使用可空修饰符？ 如：int ? a = null; 将null赋给值类型，这在数据库编程中尤其有用。在数据表中，经常出现值类型的列允许为空的情况。可空类型可以使用is as操作符。可空类型可以做参数。可空类型的核心是System.Nullable<T>，同时静态类System.Nullable为可空类型提供了很多实用的方法。
    </p>
6. 动态类型dynamic
    <p>
    dynamic类型允许编写忽略编译期间的类型检查的代码。编译器在编译的时候不再对类型进行检查，编译期默认dynamic对象支持你想要的任何特性。编译器假定给dynamic类型的对象定义的任何操作都是有效的。不要混淆dynamic和var，用var声明局部变量只是一种简化语法，它要求编译器根据表达式推断具体数据类型。var关键字只能在方法内部声明局部变量，而dynamic关键字可用于局部变量、字段和参数。表达式不能转型为var，但能转型为dynamic。必须显式初始化用var声明的变量，但无需初始化用dynamic声明的变量。不能定义对dynamic进行扩展的扩展方法。不能将lambda表达式或匿名方法作为实参传给dynamic方法调用，因为编译器推断不了要使用的类型。Dynamic优点：Dynamic类型的实例和其他类型的实例间的转换是很简单的。动态类型可以返回匿名对象，不需要再定义一个类，减少代码编写。dynamic可以简化反射（反射的常见用法：使用配置+反射+实例化对象静态方法=简单工厂类），避免利用放射获取对象频繁类型转换的性能损耗？（测试验证并非如此！！！！时间差不多一样）。如果调用一个方法是传递了dynamic类型的对象，或者被调用的对象是dynamic类型的，那么重载的判断是发生在运行时而不是编译时。常规情况下还是使用具体类型声明，避免使用dynamic。
    </p>
7. 元组(tuple)
    <p>
    数组合并了相同类型的对象，而元组合并了不同类型的对象。如：(string country, string capital, double gdp) zhongguo = ("China", "BeiJing", 555); NET Framework定义了8个泛型Tuple类(自.NET 4.0以来)和一个静态Tuple类，它们用作元组的工厂。元组用静态Tuple类的静态Create()方法创建。Create方法的泛型参数定义了要实例化的元组类型。不同的泛型Tuple类支持不同数量的元素。例如：Tuple<TI>包含一个元素, Tuple<T1, T2>包含两个元素，依此类推。如果元组包含的项超过8个，就可以使用带8个参数的Tuple类定义。最后一个模板参数是TRest，表示必须给它传递一个元组。这样就可以创建带任意个参数的元组了。C#7.0（.NET Framework 4.7）引入了 ValueTuple 结构，它是元组的值类型表示。是一个结构。ValueTuple是Tuple的扩展。Tuple好像不能创建具名项元组，且元组值只读。ValueTuple可以创建具名项元组，且元组值可修改。自从C#7.0引入元组语法后，匿名类型几乎就用不着了？？？两者区别？？？
    </p>

#### 数据类型转换
1. 显示转换
    <p>
    强制类型转换，可能造成数据丢失数据异常
    </p>
2. 隐式转换
    <p>
    不需要转型操作符也可自动转换
    </p>
3. .Parse(str) 将string转换为数值类型
4. System.Convert.ToXXX(obj) 将某类型转换为指定类型
5. .TryParse(str, out xxx) 
    <p>
    Parse()和TryParse()的关键区别在于，如转换失败TryParse()不会引发异常。TryParse()返回值表示转换是否成功，out参数为转换结果值。
    </p>
6. as 用于引用类型转换，如：object o = string as bject; o != null 表示转换成功。









