## 方法和参数
### 用方法进行重构
<p>
将一组语句转移到一个方法中，而不是把它们留在一个较大的方法中，这是一种重构形式。重构有助于减少重复代码，因为可从多个位置调用方法，而不必在每个位置都重复这些代码。重构还有助于增强代码的可读性。
</p>

### 形参和实参
<p>
方法可获取任意数量的形参，每个形参都具有特定数据类型。调用者为形参提供的值称为实参,每个实参都要和一个形参对应。
</p>

- 引用参数 Func(ref string x, ref string y){}
  <p>
  以传引用的方式传递变量，ref参数只是传递的变量的别名，而非创建新变量并将实参的值拷贝给它。
  </p>
- 输出参数 Func(char x, out char y){}
  <p>
  out参数功能上与ref参数相似，可以使得方法可以返回多个参数，但是ref在传参前必须初始化，out参数在所有正常的代码路径都必须对out参数赋值，即方法返回前要记得对out参数初始化。从C#7.0起可在调用方法前以内联的形式声明out变量，还允许使用 out _ 传参来实现放弃out参数。返回多个值应该考虑使用元组语法。
  </p>

- 只读传引用 Func(in int x){}
  <p>
  只读传引用将值类型以传引用的方式传给方法。不仅避免了每次调用方法都创建值类型的拷贝，而且被调用的方法不能修改值类型。其作用是在传值时减少拷贝量，同时把它标识为只读，从而增强性能。该语法要为参数添加in修饰符。
  </p>

- 参数数组 Func(params string[] paths){}
  <p>
  允许在调用方法时提供数量可变的参数，而不是事先就固定好参数数量。参数数组不一定是方法的唯一参数，但必须是最后一个，由于只能放在最后，所以最多只能有一个参数数组。
  </p>

- 可选参数 Func(string x = default){}
  <p>
  C#4.0新增了对可选参数的支持。声明方法时将常量值赋给参数（也可以=default），以后调用方法时就不必为每个参数提供实参。使用可选参数可以解决不得不声明一个额外的重载版本的问题，注意可选参数一定要放在所有必须参数后面，如果有参数数组，参数数组还是在最后一个。另外，默认值必须是常量或其他能在编译时确定的值。
  </p>

- 具名参数 Func(firstName: "Inigo", lastName: "Montoya");
  <p>
  C#4.0新增的另一个方法调用功能是具名参数。调用者可利用具名参数为一个参数显式赋值，而不是像以前那样只能依据参数顺序来决定哪个值赋给哪个参数。如果一个方法有很多的参数，其中许多都是可选参数，在调用方法时使用具名参数语法能带来便利，但是牺牲了方法接口的灵活性，也就是在方法参数名被修改时，之前使用具名参数的方法调用将会无法编译。
  </p>
  <p>
  方法重载、可选参数和具名参数这几种技术一起使用，会导致难以一眼看出最终调用的是哪个方法。当使用可选参数造成方法重载时，因为其中一个方法有可选参数造成两个方法都适用，编译器最终将选择无可选参数的方法。
  </p>

### 可用元组返回多个值

### 表达式主体方法
<p>
表达式主体方法不是用大括号定义方法主体，而是用=>操作符。该操作符的结果数据类型必须与方法返回类型匹配。其应用应限于最简单的方法实现，例如单行表达式。
</p>

### 方法重载
<p>
一个类中的所有方法都必须有唯一签名, C#依据方法名、参数数据类型或参数数量的差异来定义唯一性。注意方法返回类型不计入签名。如一个类包含两个或多个同名方法，就会发生方法重载。对于重载的方法，参数数量或数据类型肯定不同。方法重载是一种操作性多态。
</p>

### 递归
<p>
递归调用方法或者用递归实现方法意味着方法调用它自身。有时这是实现算法最简单的方式。用递归实现方法时，常见错误是在程序执行期间发生栈溢出(stack overflow)。这通常是由无限递归造成的。假如方法持续地调用自身，永远抵达不了标志递归结束的位置，就会发生无限递归。必须仔细检查每个使用了递归的方法，验证递归调用是有限而非无限的。
</p>

### 导入命名空间中的 using, 嵌套using, using static, 使用别名
<p>
一个.cs文件可以声明多个不同的命名空间，使用嵌套using是在自己的命名空间内导入自己需要的命名空间，只在自己命名空间内有效。没啥用？
</p>
<p>
using static指令允许将命名空间和类型名称都省略，只需写静态成员名称。  
</p>
<p>
利用using指令为命名空间或类型取一个别名。别名是在using指令起作用的范围内可以使用的替代名称，别名两个最常见的用途是消除两个同名类型的歧义和缩写长名称。
</p>


