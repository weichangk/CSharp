## 泛型

### 泛型类型概述
可利用泛型创建一个数据结构，该数据结构能进行特殊化以处理特定类型。定义这种参数化类型，使泛型类型的每个变量都具有相同的内部算法，但数据类型和方法签名可随为类型参数提供的类型实参而变。C#泛型类和结构要求用尖括号声明泛型类型参数以及提供泛型类型实参。

### 泛型优势
- 源代码保护。使用泛型算法的开发人员不需要访问算法的源代码。
- 类型安全。将泛型算法应用于一个具体的类型时，编译器和CLR能理解开发人员的意图，并保证只有与指定数据类型兼容的对象才能用于算法。试图使用不兼容类型的对象会造成编译时错误，或在运行时抛出异常。
- 更清晰的代码。由于编译器强制类型安全性，所以减少了源代码中必须进行的强制类型转换次数，使代码更容易编写和维护。
- 更佳的性能。没有泛型的时候，要想定义常规化的算法，它的所有成员都要定义成操作Object数据类型。要用这个算法来操作值类型的实例, CLR必须在调用算法的成员之前对值类型实例进行装箱。装箱造成在托管堆上进行内存分配，造成更频繁的垃圾回收，从而损害应用程序的性能。由于现在能创建一个泛型算法来操作一种具体的值类型，所以值类型的实例能以传值方式传递, CLR不再需要执行任何装箱操作。所以CLR无需验证这种转型是否类型安全，这同样提高了代码的运行速度。

### FCL中的泛型
泛型最明显的应用就是集合类。FCL在System.Collections.Generic和System.Collections.ObjectModel命名空间中提供了多个泛型集合类。System.Collections.Concurrent命名空间则提供了线程安全的泛型集合类。Microsoft建议使用泛型集合类，不建议使用非泛型集合类。这是出于几方面的考虑。首先，使用非泛型集合类，无法像使用泛型集合类那样获得类型安全性，更清晰的代码以及更佳的性能。其次，泛型类具有比非泛型类更好的对象模型。例如，虑方法数量显著变少，性能更好。另外，泛型集合类增添了一些新成员，为开发人员提供了新的功能。集合类实现了许多接口，放入集合中的对象可实现接口来执行排序和搜索等操作。FCL包含许多泛型接口定义，所以使用接口时也能享受到泛型带来的好处。常用接口在System.Collections.Generic命名空间中提供。


### 泛型基础结构

### 泛型接口

### 泛型委托

### 委托和接口的逆变和协变泛型类型参数

### 泛型方法

### 泛型和其他成员

### 可验证性和约束



