## 类
<p>
面向对象编程最基本的构造是类。一组类构成了编程抽象、模型或模板，通常对应现实世界的一个概念。类是编程中对现实事物抽象的模板。类是面向对象编程的三个主要特性：封装、继承、多态，的基础。
</p>

- 封装
  <p>
  编程中对某一事物抽象为一个类，对类的编写就是封装，封装的目的是为了隐藏数据和功能实现细节，对外提供访问接口。
  </p>
- 继承
  <p>
  继承是对某一系列事物的层次封装和扩展。继承最关键的一点是所有派生类型都继承了基类型的成员。可用派生类型以一致性的层次结构组织类，在这个层次结构中，派生类型比它们的基类型更特别。
  </p>
- 多态
  <p>
  多态性意味着一个方法或类型可具有多种形式的实现。在继承中每个派生类都共享有同一个基类或接口的可重写或实现的相同的方法签名，派生类们可以自定义重写或实现方法的实现细节。通过子类继承父类在子类中重写父类虚方法，或继承接口现实接口方法，从而实现了父类的方法在不同的派生类中有不同的形态的效果。
  </p>

### 类的声明和实例化
<p>
类和对象的关系：类是编程中对现实事物抽象的模板，它定义了对象该有的东西。对象则是类的实例，是对应类模板在计算机中生成的内存。从类创建对象的过程称为实例化。
</p>

### 实例字段 实例方法
<p>
没有使用static标志的字段和方法，每个实例化对象中都会生成属于自己的实例化成员。使用this关键字可在类的实例成员内部获取该类的引用。设计规范非必要不要乱this，使用this避免同名歧义。
</p>


### 属性
<p>
在C#中，我们可以非常自由的、毫无限制的访问公有字段，但在一些场合中，我们可能希望限制只能给字段赋于某个范围的值、或是要求字段只能读或只能写，或是在改变字段时能改变对象的其他一些状态，这些单靠字段是无法做到的，于是就有了属性，属性中包含两个块：set和get，set块负责属性的写入工作，get块负责属性的读取工作。在两个块中都可以做一些其他操作，如在set中验证赋的值是否符合要求并决定是否进行赋值。当缺少其中一块时属性就只能读或只能写，set和get块中属性必需有一个才有意义。如果不需要额外逻辑，要优先使用自动实现的属性，而不是属性加简单支持字段。使用属性验证时避免从属性取值方法抛出异常，拦截赋值对参数进行验证是属性的优点之一。应该使用属性（而不是字段）来暴露数据。
</p>

### 构造函数
<p>
定义构造函数需创建一个无返回类型的方法，方法名必须和类名完全一样。如果类没有显式定义的构造函数, C#编译器会在编译时自动添加一个。该构造函数不获取参数称为默认构造函数。一旦为类显式添加了构造函数, C#编译器就不再自动提供默认构造函数，如果此时还像调用默认构造函数，需要显示定义默认无参构造函数。
</p>
<p>
使用对象初始化器在调用构造函数时可以在后面的大括号中添加成员初始化列表。集合初始化器和对象初始化器语法相似，用于集合实例化期间向集合项赋值。
</p>
<p>
构造函数可以重载。可以从一个构造函数中调用另一个构造函数，避免重复代码，这称为构造函数链，用构造函数初始化器实现，构造函数初始化器会在执行当前构造函数的实现之前，判断要调用另外哪一个构造函数。为了从一个构造函数中调用同一个类的另一个构造函数, C#语法是在一个冒号后添加this关键字，再添加被调用构造函数的参数列表。
</p>

### 解构函数
<p>
构造函数允许获取多个参数并把它们全部封装到一个对象中。但在C#7.0之前没有一个显式的语言构造来做相反的事情，即把封装好的项拆分为它的各个组成部分。当然可以将每个属性手动赋给变量，但如果有太多这样的变量就需要大量单独的语句。自C#7.0推出元组语法后，该操作得到极大简化。从C#7.0起可直接将对象实例赋给一个元组，从而隐式调用Deconstruct()方法(称为解构函数)。为声明解构函数，方法名必须是Deconstruct，其签名是返回void并接收两个或更多out参数。基于该签名，可将对象实例直接赋给一个元组而无须显式方法调用。
</p>

### 终结器
<p>
构造函数定义了在类的实例化过程中发生的事情。为定义在对象销毁过程中发生的事情, C#提供了终结器。和C++的析构器不同，终结器不是在对一个对象的所有引用都消失后马上运行。相反，终结器是在对象被判定“不可到达”之后的不确定时间内执行。具体地说，垃圾回收器会在一次垃圾回收过程中识别出带有终结器的对象，但不是立即回收这些对象，而是将它们添加到一个终结队列中。一个独立的线程遍历终结队列中的每一个对象，调用其终结器，然后将其从队列中删除，使其再次可供垃圾回收器处理。
</p>

### 静态
<p>
静态字段主要存储对应于类的数据，而实例字段主要存储和对象关联的数据。由于静态方法不通过实例引用，所以this关键字在静态方法中无效，即静态方法中不能直接调用非静态成员。要在静态方法内部直接访问实例字段或实例方法，必须先获得对字段或方法所属的那个实例的引用。
</p>

- 静态构造函数
<p>
静态构造函数不显式调用。“运行时”在首次访问类时自动调用静态构造函数，“首次访问类”可能发生在调用普通构造函数时，也可能发生在访问类的静态方法或字段时，由于静态构造函数不能显式调用，不允许任何参数，不允许有访问修饰符。静态构造函数的作用是将类中的静态数据初始化成特定值，尤其是在无法通过声明时的一次简单赋值来获得初始值的时候。考虑要么以内联方式初始化静态字段(而不要使用静态构造函数)，要么在声明时初始化。
</p>

- 静态类，不能有实例成员，不可以实例化，不能派生

### 扩展方法
<p>
C#3.0引入了扩展方法的概念，在静态类中能模拟为其他类创建实例方法。只需更改静态方法的签名，使第一个参数成为要扩展的类型，并在类型名称前附加this关键字。如扩展方法的签名和被扩展类型中现有的签名匹配，扩展方法将被覆盖永远不会得到调用。通过继承要优于使用扩展方法，扩展方法无益于建立清楚的版本控制机制。
</p>

### 嵌套类
<p>
除了定义方法和字段，在类中还可定义另一个类，这称为嵌套类。嵌套类中的this成员引用嵌套类而非包容类的实例。嵌套类要访问包容类的实例，一个方案是显式传递包容类的实例，比如通过构造函数或方法参数。嵌套类另一个有趣的地方在于它能访问包容类的任何成员，其中包括私有成员。反之则不然，包容类不能访问嵌套类的私有成员。嵌套类用得很少，要从包容类型外部引用，就不能定义成嵌套类，另外要警惕public嵌套类，它们意味着不良的编码风格，可能造成混淆和难以阅读。
</p>

### 分部类
<p>
从C#2.0起支持分部类。使用class前的上下文关键字partial来声明分部类。分部类是一个类的多个部分，编译器可把它们合并成一个完整的类。虽然可在同一个文件中定义两个或更多分部类，但分部类的目的就是将一个类的定义划分到多个文件中。这对生成或修改代码的工具尤其有用。通过分部类，由工具处理的文件可独立于开发者手动编码的文件。分部类除了用于代码生成器，分部类另一个常见的应用是将每个嵌套类都放到它们自己的文件中，这符合编码规范将每个类定义都放到它自己的文件中。
</p>

### 分部方法
<p>
分部方法只能存在于分部类中，而且和分部类相似，主要作用是为代码生成提供方便。分部方法允许声明方法而不需要实现，但如果包含了可选的实现，该实现就可放到某个姊妹分部类定义中，该定义可能在单独的文件中。分部方法必须返回void, out参数在分部方法中不允许，需要返回值可以使用ref参数。
</p>

### const 和 readonly
<P>
const字段(称为常量字段)包含在编译时确定的值，运行时不可修改。常量字段自动成为静态字段，因为不需要为每个对象实例都生成新的字段实例，但将常量字段显式声明为static会造成编译错误。
</P>
<p>
和const不同, readonly修饰符只能用于字段(不能用于局部变量)，它指出字段值只能从构造函数中更改，或在声明时通过初始化器指定。每个实例的readonly字段值都可以不同，readonly字段可以是实例或静态字段。
</p>